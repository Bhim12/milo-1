{
  "version": 3,
  "sources": ["../src/merch-stock.js", "../src/constants.js", "../src/utils.js", "../src/async-control.js", "../src/commerce-aware.js"],
  "sourcesContent": ["import { LitElement } from 'lit';\nimport { CommerceAware } from './commerce-aware.js';\nimport { showOffers } from './utils.js';\n\nconst TAG_NAME = 'merch-stock';\n\nexport class Stock extends CommerceAware(LitElement, 'merch-stock') {\n    #updateSelected() {\n        const { offers, selected } = this;\n        if (!offers) return;\n        showOffers(this.offers, (offer) => offer === selected);\n        this.control.resolve();\n    }\n\n    get selected() {\n        return super.selected;\n    }\n\n    set selected(value) {\n        super.selected = value;\n    }\n\n    createRenderRoot() {\n        return this;\n    }\n\n    /**\n     * Reacts to updates of this component.\n     * @param {Map<string, any>} changed\n     */\n    updated(changed) {\n        super.updated(changed);\n        const { commerce } = this;\n        if (commerce && changed.has('commerce')) {\n            this.discoverOffers(this);\n        }\n        if (changed.has('offers') || changed.has('selected')) {\n            this.#updateSelected();\n        }\n    }\n}\n\nwindow.customElements.define(TAG_NAME, Stock);\n", "/**\n * Common namespace prefix for CSS classes and DOM event types.\n * @see https://git.corp.adobe.com/wcms/team/discussions/27\n */\nexport const NAMESPACE = 'merch';\n/**\n * This CSS class name is used to:\n * - show only selected offer on a card connected to a subscription panel\n * - TBD\n */\nexport const CLASS_NAME_HIDDEN = 'hidden';\n/**\n * Event type dispatched by the commenrce service whenever it is ready.\n * Should be in sync with `packages/commerce/src/constants.js`.\n */\nexport const EVENT_TYPE_READY = 'wcms:commerce:ready';\n/**\n * Tag name of the commerce service component.\n * Should be in sync with `packages/commerce/src/constants.js`.\n */\nexport const TAG_NAME_SERVICE = 'wcms-commerce';\n", "import { CLASS_NAME_HIDDEN, NAMESPACE } from './constants.js';\n\nexport function debounce(func, delay) {\n    let debounceTimer;\n    return function () {\n        const context = this;\n        const args = arguments;\n        clearTimeout(debounceTimer);\n        debounceTimer = setTimeout(() => func.apply(context, args), delay);\n    };\n}\n\nexport const getSlotText = (element, name) =>\n    element.querySelector(`[slot=\"${name}\"]`).textContent.trim();\n\n/**\n * Dispatches custom event of the given `type` on the given `target`.\n * @template T\n * @param {EventTarget} target\n * @param {string} type\n * @param {CustomEventInit<T>} options\n */\nexport const dispatchAsyncEvent = (\n    target,\n    type,\n    { bubbles = true, cancelable, composed, detail } = {}\n) =>\n    window.setTimeout(() =>\n        target?.dispatchEvent(\n            new CustomEvent(type, {\n                bubbles,\n                cancelable,\n                composed,\n                detail,\n            })\n        )\n    );\n\n/**\n * Finds the closest common ancestor for given array of DOM elements.\n * Note: the search may go up DOM tree beyoud some expected container (e.g. card) and event result in `document.body`.\n * For a good solution, @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n * @param { Element[] } elements\n * Array of DOM elements to find the common ancestor for.\n * @returns { Element | null }\n * The closest common ancestor of the given elements or `null` if none found.\n */\nexport function getCommonAncestor(...elements) {\n    const [first, ...rest] = elements;\n    if (!first) return null;\n    let ancestor = first.parentElement;\n    if (!rest.length) return ancestor;\n    while (ancestor) {\n        if (rest.every((element) => ancestor.contains(element))) {\n            return ancestor;\n        }\n        ancestor = ancestor.parentElement;\n    }\n    return null;\n}\n\n/**\n * @param {Commerce.Placeholder} placeholder\n * @returns {boolean}\n */\nexport function isRegularPrice(placeholder) {\n    if (placeholder.isInlinePrice) {\n        const { template } = placeholder.dataset;\n        if (template === 'price' || !template) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Joins an array of string `tokens`,\n * filtering out `falsy` values and replacing non-word characters in each token.\n * @param { string[] } tokens\n * Array of strings to be joined.\n * @param { string } delimiter\n * Delimiter used to join the tokens and replace non-word characters.\n */\nconst joinTokens = (tokens, delimiter) =>\n    tokens\n        .filter((token) => token)\n        .map((token) => token.replace(/\\W+/g, delimiter))\n        .join(delimiter);\n\n/**\n * Creates a namespaced CSS class name.\n * Replaces any sequence of non-word characters with a single hyphen.\n * @param {...string} args - Components of the class name.\n * @returns {string} - The namespaced and cleaned CSS class name.\n */\nexport const makeCssClassName = (...args) =>\n    `${NAMESPACE}-${joinTokens(args, '-')}`;\n\n/**\n * Creates a namespaced event type.\n * Replaces any sequence of non-word characters with a single colon.\n * @param {...string} args - Components of the event type.\n * @returns {string} The namespaced and cleaned event type.\n */\nexport const makeEventTypeName = (...args) =>\n    `${NAMESPACE}:${joinTokens(args, ':')}`;\n\n/**\n * Returns a function dispatching custom event of the given `type` on the given `target`.\n * @template T\n * @param {EventTarget} target\n * @param {string} type\n * @param {CustomEventInit<T>} options\n * @returns {(options: CustomEventInit<T>) => void}\n */\nexport function makeAsyncEventDispatch(\n    target,\n    type,\n    { bubbles = true, cancelable, composed } = {}\n) {\n    return (options = {}) =>\n        dispatchAsyncEvent(target, type, {\n            bubbles,\n            cancelable,\n            composed,\n            ...options,\n        });\n}\n\n/**\n * @param {Commerce.Offers} offers\n * @param {Commerce.filterOffer} filter\n */\nexport function showOffers(offers, filter = () => true) {\n    let i = 0;\n    for (const offer of offers.values()) {\n        offer.container?.classList.toggle(\n            CLASS_NAME_HIDDEN,\n            !filter(offer, i++)\n        );\n    }\n}\n", "import {\n    dispatchAsyncEvent,\n    makeCssClassName,\n    makeEventTypeName,\n} from './utils.js';\n\nconst FAILED = 'failed';\nconst PENDING = 'pending';\nconst RESOLVED = 'resolved';\n\n/**\n * Notifies observing modules about results of an asynchronous operation that\n * can be reccurently performed by a component from time to time.\n * Basically, any async component can be in one of three states:\n * - `pending` - the component is waiting for the async operation to complete;\n * - `resolved` - the async operation has completed successfully;\n * - `failed` - the async operation has failed.\n * This helper toggles state reflecting css classes and emits state events.\n */\nexport class AsyncControl {\n    /** @type {Error | undefined} */\n    #error;\n    /**\n     * @type {{\n     *  cssClassNames?: Record<string, string>;\n     *  eventOptions?: EventInit;\n     *  eventTypeNames?: Record<string, string>;\n     * }}\n     */\n    #options = {};\n    /** @type {string} */\n    #state;\n    #target;\n\n    /**\n     * Creates a new instance of control, pending for resolution.\n     * @param {Element} target\n     * @param {{\n     *  cssPrefix?: string;\n     *  eventOptions?: EventInit;\n     *  eventPrefix?: string;\n     * }} options\n     */\n    constructor(\n        target,\n        {\n            cssPrefix = 'component',\n            eventOptions,\n            eventPrefix = 'component',\n        } = {}\n    ) {\n        this.#target = target;\n        const options = this.#options;\n        options.cssClassNames = {};\n        options.eventOptions = eventOptions;\n        options.eventTypeNames = {};\n        for (const state of [FAILED, PENDING, RESOLVED]) {\n            options.cssClassNames[state] = makeCssClassName(cssPrefix, state);\n            options.eventTypeNames[state] = makeEventTypeName(\n                eventPrefix,\n                state\n            );\n        }\n        this.init();\n    }\n\n    #notify(detail) {\n        const { cssClassNames, eventOptions, eventTypeNames } = this.#options;\n        [FAILED, PENDING, RESOLVED].forEach((state) => {\n            this.#target.classList.toggle(\n                cssClassNames[state],\n                state === this.#state\n            );\n        });\n        dispatchAsyncEvent(this.#target, eventTypeNames[this.#state], {\n            ...eventOptions,\n            detail,\n        });\n    }\n\n    /**\n     * Gets the latest rejection error.\n     * @returns {Error | undefined}\n     */\n    get error() {\n        return this.#error;\n    }\n\n    /**\n     * Returns the promise pending for completion of the currently active async operation.\n     * If no operation is active at the moment, it returns a settled promise.\n     * @returns {Promise}\n     */\n    get promise() {\n        return new Promise((resolve, reject) => {\n            this.subscribe(resolve, reject);\n        });\n    }\n\n    /**\n     * Returns the current state of the object.\n     * @returns {string}\n     */\n    get state() {\n        return this.#state;\n    }\n\n    /**\n     * Signals start of a new asynchronous operation and returns.\n     * Returns `false` if object was already in pending state.\n     */\n    init() {\n        if (this.#state !== PENDING) {\n            this.#state = PENDING;\n            this.#error = undefined;\n            this.#notify();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Signals the success of the asynchronous operation and stores its `value`\n     * given that the caller provides the `secret` matching the latest made.\n     * @param {Error} error\n     * True if the `secret` has matched and control was resolved.\n     */\n    reject(error) {\n        if (this.#state !== PENDING) return false;\n        this.#error = error;\n        this.#state = FAILED;\n        this.#notify();\n        return true;\n    }\n\n    /**\n     * Signals the success of the asynchronous operation and stores its `value`\n     * given that the caller provides the `secret` matching the latest made.\n     * @param {Promise<any>} [promise]\n     * True if the `secret` has matched and control was resolved.\n     */\n    async resolve(promise) {\n        if (this.#state !== PENDING) return false;\n        if (promise) await promise;\n        this.#state = RESOLVED;\n        this.#notify();\n        return true;\n    }\n\n    subscribe(resolved, failed, once) {\n        const { eventTypeNames } = this.#options;\n        const target = this.#target;\n        let triggered = false;\n        const onFailed = (event) => {\n            if (once && triggered) return;\n            triggered = true;\n            failed(event.detail);\n        };\n        const onResolved = (event) => {\n            if (once && triggered) return;\n            triggered = true;\n            resolved(event.detail);\n        };\n        const state = this.#state;\n        if (FAILED === state) failed?.(this.#error);\n        else if (RESOLVED === state) resolved(this.#target);\n        if (triggered) return () => {};\n        const options = once ? { once: true } : undefined;\n        target.addEventListener(eventTypeNames[RESOLVED], onResolved, options);\n        if (failed) {\n            target.addEventListener(eventTypeNames[FAILED], onFailed, options);\n        }\n        return () => {\n            target.removeEventListener(eventTypeNames[RESOLVED], onResolved);\n            if (failed) {\n                target.removeEventListener(eventTypeNames[FAILED], onFailed);\n            }\n        };\n    }\n\n    static FAILED = FAILED;\n    static PENDING = PENDING;\n    static RESOLVED = RESOLVED;\n}\n", "import { AsyncControl } from './async-control.js';\nimport { EVENT_TYPE_READY, TAG_NAME_SERVICE } from './constants.js';\nimport { getCommonAncestor } from './utils.js';\n\nexport const UNKNOWN_PLAN_TYPE = 'UNKNOWN';\n\n/**\n * Groups provided commerce placeholders into offers.\n * @param {Commerce.Placeholder[]} placeholders\n * @param {Element} container\n * @param {{\n *  filterOffer?: Commerce.filterOffer;\n *  filterPlaceholder?: Commerce.filterPlaceholder;\n * }} filters\n */\nasync function makeOffers(container, filters, placeholders) {\n    /** @type {Commerce.Offers} */\n    const offers = new Map();\n    // Note: all placeholders are awaited in parallel\n    await Promise.allSettled(\n        placeholders.map((placeholder) => placeholder.onceSettled())\n    );\n    let i = 0;\n    for (const placeholder of placeholders) {\n        if (!filters.filterPlaceholder(placeholder, i++)) continue;\n        const wcsOffers = placeholder?.value ?? [];\n        // Note: `UNKNOWN_PLAN_TYPE` - special group for failed commerce placeholders, perhaps should be ignored in render\n        for (const { planType = UNKNOWN_PLAN_TYPE } of wcsOffers) {\n            // Use group for this plan type, create if needed\n            const group = offers.get(planType) ?? {\n                checkoutLinks: [],\n                inlinePrices: [],\n                planType,\n                get container() {\n                    const candidate = getCommonAncestor(\n                        ...group.checkoutLinks,\n                        ...group.inlinePrices\n                    );\n                    if (\n                        candidate?.compareDocumentPosition(container) &\n                        Node.DOCUMENT_POSITION_CONTAINS\n                    ) {\n                        return candidate;\n                    }\n                    return undefined;\n                },\n            };\n            // Classify placeholder\n            if (placeholder.isCheckoutLink) {\n                group.checkoutLinks.push(placeholder);\n            } else if (placeholder.isInlinePrice) {\n                group.inlinePrices.push(placeholder);\n            }\n            offers.set(planType, group);\n        }\n    }\n    i = 0;\n    for (const offer of offers.values()) {\n        if (!filters.filterOffer(offer, i++)) {\n            offers.delete(offer.planType);\n        }\n    }\n    return offers;\n}\n\n/**\n * Notifies the provided `callback` every time the commerce service is initialised,\n * providing currently active instance of the service.\n * @param {(commerce: Commerce.Instance) => void} callback\n * @param {{ once?: boolean; }} options\n * @returns {() => void}\n * A function, stopping notifications when called.\n */\nexport function discoverService(callback, { once = false } = {}) {\n    const { head } = document;\n    let latest = null;\n    function discover() {\n        /** @type { Commerce.Instance } */\n        const current = head.querySelector(TAG_NAME_SERVICE);\n        if (current === latest) return;\n        latest = current;\n        if (current) callback(current);\n    }\n    head.addEventListener(EVENT_TYPE_READY, discover, { once });\n    window.setTimeout(discover);\n    return () => head.removeEventListener(EVENT_TYPE_READY, discover);\n}\n\n/**\n * Lit mixin for web components requiring active instance of the commerce service.\n * Creates `commerce`, `log` and `offers` properties on the enhanced component.\n * @param {Commerce.ComponentConstructor} Component - Component constructor.\n * @param {string} tagName - Tag name of the component.\n * @example\n * class MyElement extends CommerceAware(LitElement, 'my-element') {}\n */\nexport function CommerceAware(Component, tagName) {\n    // TODO: `name` arg can be replaced with a call to `CustomElementRegistry.getName` method in the future\n    // SEE: https://caniuse.com/mdn-api_customelementregistry_getname\n    return class CommerceAware extends Component {\n        /**\n         * Notifies connected components about state changes.\n         */\n        #control = new AsyncControl(this, {\n            cssPrefix: tagName,\n            eventPrefix: tagName,\n        });\n        /** @type {Commerce.Instance | undefined} */\n        #commerce;\n        /** @type {() => void} */\n        #dispose;\n        /** @type {Commerce.Log.Instance | undefined} */\n        #log;\n        /** @type {Commerce.Offers | undefined} */\n        #offers;\n        /**\n         * Preselected offer type, if any.\n         * Stored in case if offers are still pending but selection is already requested.\n         * @type { any }\n         */\n        #preselected;\n        /**\n         * The currently selected offer, if any.\n         * @type { Commerce.Offer | undefined }\n         */\n        #selected;\n\n        /**\n         * @param { string | Commerce.Offer } value\n         */\n        #updateSelected(value) {\n            const { offers } = this;\n            if (!offers) return;\n            const selected = offers.get(value) ?? offers.get(value?.planType);\n            if (selected === this.#selected) return;\n            const old = this.#selected;\n            this.#selected = selected;\n            this.requestUpdate('selected', old);\n            /* c8 ignore start */\n            this.log?.debug('Selected:', {\n                selected: this.selected?.planType,\n                element: this,\n            });\n            /* c8 ignore stop */\n        }\n\n        get commerce() {\n            return this.#commerce;\n        }\n\n        get control() {\n            return this.#control;\n        }\n\n        get log() {\n            return this.#log;\n        }\n\n        get offers() {\n            return this.#offers;\n        }\n\n        /**\n         * Returns a promise resolving when this panel has all data to render the offers,\n         * or rejecting with the error occured during offer resolution.\n         */\n        get resolveComplete() {\n            return this.#control.promise;\n        }\n\n        /**\n         * Returns the currently selected selected offer, if any.\n         * @returns { Commerce.Offer | undefined }\n         */\n        get selected() {\n            return this.#selected;\n        }\n\n        /**\n         * Allows programmatic control of the selected offer.\n         * Accepts plan type as string or offer object (and uses its pla type to select among own offers).\n         * If given plan type cannot be found, selects first offer in the document order.\n         * @param { string | Commerce.Offer } value\n         */\n        set selected(value) {\n            this.#preselected = value;\n            this.#updateSelected(value);\n        }\n\n        connectedCallback() {\n            super.connectedCallback();\n            this.#dispose = discoverService((commerce) => {\n                const old = [this.#commerce, this.#log, this.#offers];\n                this.#commerce = commerce;\n                this.#log = commerce.Log.module(tagName);\n                this.#offers = undefined;\n                this.#log.debug('Connected:', { element: this });\n                this.requestUpdate('commerce', old[0]);\n                this.requestUpdate('log', old[1]);\n                this.requestUpdate('offers', old[2]);\n            });\n        }\n\n        disconnectedCallback() {\n            this.#log.debug('Disconnected:', { element: this });\n            super.disconnectedCallback();\n            this.#dispose?.();\n        }\n\n        /**\n         * Override in your component to filter some of discovered commerce offers out of `this.offers`.\n         * By default, includes all offers.\n         * @param {Commerce.Offer} offer\n         * @param {number} index\n         */\n        filterOffer(offer, index) {\n            return true;\n        }\n\n        /**\n         * Override in your component to filter some of discovered commerce placeholders out of `this.offers`.\n         * By default, includes all offers.\n         * @param {Commerce.Placeholder} placeholder\n         * @param {number} index\n         */\n        filterPlaceholder(placeholder, index) {\n            return true;\n        }\n\n        /**\n         * Find all commerce placeholders in the `container` and groups them into offers.\n         * An offer contains lists of checkout link and inline price elements having same plan type.\n         * @param { Element } container\n         */\n        async discoverOffers(container) {\n            this.#control.init();\n            const placeholders = [];\n            const { commerce } = this;\n            if (commerce) {\n                const { CheckoutLink, InlinePrice } = commerce;\n                placeholders.push(\n                    ...CheckoutLink.getCheckoutLinks(container),\n                    ...InlinePrice.getInlinePrices(container)\n                );\n                this.log.debug('Discovering offers:', {\n                    container,\n                    element: this,\n                });\n            }\n            const old = this.#offers;\n            try {\n                const offers = await makeOffers(container, this, placeholders);\n                this.#offers = offers;\n                this.requestUpdate('offers', old);\n                this.#updateSelected(this.#preselected);\n            } catch (error) {\n                this.#control.reject(error);\n            }\n        }\n    };\n}\n"],
  "mappings": ";AAAA,OAAS,cAAAA,MAAkB,4BCIpB,IAAMC,EAAY,QAMZC,EAAoB,SAKpBC,EAAmB,sBAKnBC,EAAmB,gBCEzB,IAAMC,EAAqB,CAC9BC,EACAC,EACA,CAAE,QAAAC,EAAU,GAAM,WAAAC,EAAY,SAAAC,EAAU,OAAAC,CAAO,EAAI,CAAC,IAEpD,OAAO,WAAW,IACdL,GAAQ,cACJ,IAAI,YAAYC,EAAM,CAClB,QAAAC,EACA,WAAAC,EACA,SAAAC,EACA,OAAAC,CACJ,CAAC,CACL,CACJ,EAWG,SAASC,KAAqBC,EAAU,CAC3C,GAAM,CAACC,EAAO,GAAGC,CAAI,EAAIF,EACzB,GAAI,CAACC,EAAO,OAAO,KACnB,IAAIE,EAAWF,EAAM,cACrB,GAAI,CAACC,EAAK,OAAQ,OAAOC,EACzB,KAAOA,GAAU,CACb,GAAID,EAAK,MAAOE,GAAYD,EAAS,SAASC,CAAO,CAAC,EAClD,OAAOD,EAEXA,EAAWA,EAAS,aACxB,CACA,OAAO,IACX,CAwBA,IAAME,EAAa,CAACC,EAAQC,IACxBD,EACK,OAAQE,GAAUA,CAAK,EACvB,IAAKA,GAAUA,EAAM,QAAQ,OAAQD,CAAS,CAAC,EAC/C,KAAKA,CAAS,EAQVE,EAAmB,IAAIC,IAChC,GAAGC,CAAS,IAAIN,EAAWK,EAAM,GAAG,CAAC,GAQ5BE,EAAoB,IAAIF,IACjC,GAAGC,CAAS,IAAIN,EAAWK,EAAM,GAAG,CAAC,GA4BlC,SAASG,EAAWC,EAAQC,EAAS,IAAM,GAAM,CACpD,IAAIC,EAAI,EACR,QAAWC,KAASH,EAAO,OAAO,EAC9BG,EAAM,WAAW,UAAU,OACvBC,EACA,CAACH,EAAOE,EAAOD,GAAG,CACtB,CAER,CCvIA,IAAMG,EAAS,SACTC,EAAU,UACVC,EAAW,WAWJC,EAAN,KAAmB,CAEtBC,GAQAC,GAAW,CAAC,EAEZC,GACAC,GAWA,YACIC,EACA,CACI,UAAAC,EAAY,YACZ,aAAAC,EACA,YAAAC,EAAc,WAClB,EAAI,CAAC,EACP,CACE,KAAKJ,GAAUC,EACf,IAAMI,EAAU,KAAKP,GACrBO,EAAQ,cAAgB,CAAC,EACzBA,EAAQ,aAAeF,EACvBE,EAAQ,eAAiB,CAAC,EAC1B,QAAWC,IAAS,CAACb,EAAQC,EAASC,CAAQ,EAC1CU,EAAQ,cAAcC,CAAK,EAAIC,EAAiBL,EAAWI,CAAK,EAChED,EAAQ,eAAeC,CAAK,EAAIE,EAC5BJ,EACAE,CACJ,EAEJ,KAAK,KAAK,CACd,CAEAG,GAAQC,EAAQ,CACZ,GAAM,CAAE,cAAAC,EAAe,aAAAR,EAAc,eAAAS,CAAe,EAAI,KAAKd,GAC7D,CAACL,EAAQC,EAASC,CAAQ,EAAE,QAASW,GAAU,CAC3C,KAAKN,GAAQ,UAAU,OACnBW,EAAcL,CAAK,EACnBA,IAAU,KAAKP,EACnB,CACJ,CAAC,EACDc,EAAmB,KAAKb,GAASY,EAAe,KAAKb,EAAM,EAAG,CAC1D,GAAGI,EACH,OAAAO,CACJ,CAAC,CACL,CAMA,IAAI,OAAQ,CACR,OAAO,KAAKb,EAChB,CAOA,IAAI,SAAU,CACV,OAAO,IAAI,QAAQ,CAACiB,EAASC,IAAW,CACpC,KAAK,UAAUD,EAASC,CAAM,CAClC,CAAC,CACL,CAMA,IAAI,OAAQ,CACR,OAAO,KAAKhB,EAChB,CAMA,MAAO,CACH,OAAI,KAAKA,KAAWL,GAChB,KAAKK,GAASL,EACd,KAAKG,GAAS,OACd,KAAKY,GAAQ,EACN,IAEJ,EACX,CAQA,OAAOO,EAAO,CACV,OAAI,KAAKjB,KAAWL,EAAgB,IACpC,KAAKG,GAASmB,EACd,KAAKjB,GAASN,EACd,KAAKgB,GAAQ,EACN,GACX,CAQA,MAAM,QAAQQ,EAAS,CACnB,OAAI,KAAKlB,KAAWL,EAAgB,IAChCuB,GAAS,MAAMA,EACnB,KAAKlB,GAASJ,EACd,KAAKc,GAAQ,EACN,GACX,CAEA,UAAUS,EAAUC,EAAQC,EAAM,CAC9B,GAAM,CAAE,eAAAR,CAAe,EAAI,KAAKd,GAC1BG,EAAS,KAAKD,GAChBqB,EAAY,GACVC,EAAYC,GAAU,CACpBH,GAAQC,IACZA,EAAY,GACZF,EAAOI,EAAM,MAAM,EACvB,EACMC,EAAcD,GAAU,CACtBH,GAAQC,IACZA,EAAY,GACZH,EAASK,EAAM,MAAM,EACzB,EACMjB,EAAQ,KAAKP,GAGnB,GAFIN,IAAWa,EAAOa,IAAS,KAAKtB,EAAM,EACjCF,IAAaW,GAAOY,EAAS,KAAKlB,EAAO,EAC9CqB,EAAW,MAAO,IAAM,CAAC,EAC7B,IAAMhB,EAAUe,EAAO,CAAE,KAAM,EAAK,EAAI,OACxC,OAAAnB,EAAO,iBAAiBW,EAAejB,CAAQ,EAAG6B,EAAYnB,CAAO,EACjEc,GACAlB,EAAO,iBAAiBW,EAAenB,CAAM,EAAG6B,EAAUjB,CAAO,EAE9D,IAAM,CACTJ,EAAO,oBAAoBW,EAAejB,CAAQ,EAAG6B,CAAU,EAC3DL,GACAlB,EAAO,oBAAoBW,EAAenB,CAAM,EAAG6B,CAAQ,CAEnE,CACJ,CAEA,OAAO,OAAS7B,EAChB,OAAO,QAAUC,EACjB,OAAO,SAAWC,CACtB,ECnLO,IAAM8B,EAAoB,UAWjC,eAAeC,EAAWC,EAAWC,EAASC,EAAc,CAExD,IAAMC,EAAS,IAAI,IAEnB,MAAM,QAAQ,WACVD,EAAa,IAAKE,GAAgBA,EAAY,YAAY,CAAC,CAC/D,EACA,IAAIC,EAAI,EACR,QAAWD,KAAeF,EAAc,CACpC,GAAI,CAACD,EAAQ,kBAAkBG,EAAaC,GAAG,EAAG,SAClD,IAAMC,EAAYF,GAAa,OAAS,CAAC,EAEzC,OAAW,CAAE,SAAAG,EAAWT,CAAkB,IAAKQ,EAAW,CAEtD,IAAME,EAAQL,EAAO,IAAII,CAAQ,GAAK,CAClC,cAAe,CAAC,EAChB,aAAc,CAAC,EACf,SAAAA,EACA,IAAI,WAAY,CACZ,IAAME,EAAYC,EACd,GAAGF,EAAM,cACT,GAAGA,EAAM,YACb,EACA,GACIC,GAAW,wBAAwBT,CAAS,EAC5C,KAAK,2BAEL,OAAOS,CAGf,CACJ,EAEIL,EAAY,eACZI,EAAM,cAAc,KAAKJ,CAAW,EAC7BA,EAAY,eACnBI,EAAM,aAAa,KAAKJ,CAAW,EAEvCD,EAAO,IAAII,EAAUC,CAAK,CAC9B,CACJ,CACAH,EAAI,EACJ,QAAWM,KAASR,EAAO,OAAO,EACzBF,EAAQ,YAAYU,EAAON,GAAG,GAC/BF,EAAO,OAAOQ,EAAM,QAAQ,EAGpC,OAAOR,CACX,CAUO,SAASS,EAAgBC,EAAU,CAAE,KAAAC,EAAO,EAAM,EAAI,CAAC,EAAG,CAC7D,GAAM,CAAE,KAAAC,CAAK,EAAI,SACbC,EAAS,KACb,SAASC,GAAW,CAEhB,IAAMC,EAAUH,EAAK,cAAcI,CAAgB,EAC/CD,IAAYF,IAChBA,EAASE,EACLA,GAASL,EAASK,CAAO,EACjC,CACA,OAAAH,EAAK,iBAAiBK,EAAkBH,EAAU,CAAE,KAAAH,CAAK,CAAC,EAC1D,OAAO,WAAWG,CAAQ,EACnB,IAAMF,EAAK,oBAAoBK,EAAkBH,CAAQ,CACpE,CAUO,SAASI,EAAcC,EAAWC,EAAS,CAG9C,OAAO,cAA4BD,CAAU,CAIzCE,GAAW,IAAIC,EAAa,KAAM,CAC9B,UAAWF,EACX,YAAaA,CACjB,CAAC,EAEDG,GAEAC,GAEAC,GAEAC,GAMAC,GAKAC,GAKAC,GAAgBC,EAAO,CACnB,GAAM,CAAE,OAAA9B,CAAO,EAAI,KACnB,GAAI,CAACA,EAAQ,OACb,IAAM+B,EAAW/B,EAAO,IAAI8B,CAAK,GAAK9B,EAAO,IAAI8B,GAAO,QAAQ,EAChE,GAAIC,IAAa,KAAKH,GAAW,OACjC,IAAMI,EAAM,KAAKJ,GACjB,KAAKA,GAAYG,EACjB,KAAK,cAAc,WAAYC,CAAG,EAElC,KAAK,KAAK,MAAM,YAAa,CACzB,SAAU,KAAK,UAAU,SACzB,QAAS,IACb,CAAC,CAEL,CAEA,IAAI,UAAW,CACX,OAAO,KAAKT,EAChB,CAEA,IAAI,SAAU,CACV,OAAO,KAAKF,EAChB,CAEA,IAAI,KAAM,CACN,OAAO,KAAKI,EAChB,CAEA,IAAI,QAAS,CACT,OAAO,KAAKC,EAChB,CAMA,IAAI,iBAAkB,CAClB,OAAO,KAAKL,GAAS,OACzB,CAMA,IAAI,UAAW,CACX,OAAO,KAAKO,EAChB,CAQA,IAAI,SAASE,EAAO,CAChB,KAAKH,GAAeG,EACpB,KAAKD,GAAgBC,CAAK,CAC9B,CAEA,mBAAoB,CAChB,MAAM,kBAAkB,EACxB,KAAKN,GAAWf,EAAiBwB,GAAa,CAC1C,IAAMD,EAAM,CAAC,KAAKT,GAAW,KAAKE,GAAM,KAAKC,EAAO,EACpD,KAAKH,GAAYU,EACjB,KAAKR,GAAOQ,EAAS,IAAI,OAAOb,CAAO,EACvC,KAAKM,GAAU,OACf,KAAKD,GAAK,MAAM,aAAc,CAAE,QAAS,IAAK,CAAC,EAC/C,KAAK,cAAc,WAAYO,EAAI,CAAC,CAAC,EACrC,KAAK,cAAc,MAAOA,EAAI,CAAC,CAAC,EAChC,KAAK,cAAc,SAAUA,EAAI,CAAC,CAAC,CACvC,CAAC,CACL,CAEA,sBAAuB,CACnB,KAAKP,GAAK,MAAM,gBAAiB,CAAE,QAAS,IAAK,CAAC,EAClD,MAAM,qBAAqB,EAC3B,KAAKD,KAAW,CACpB,CAQA,YAAYhB,EAAO0B,EAAO,CACtB,MAAO,EACX,CAQA,kBAAkBjC,EAAaiC,EAAO,CAClC,MAAO,EACX,CAOA,MAAM,eAAerC,EAAW,CAC5B,KAAKwB,GAAS,KAAK,EACnB,IAAMtB,EAAe,CAAC,EAChB,CAAE,SAAAkC,CAAS,EAAI,KACrB,GAAIA,EAAU,CACV,GAAM,CAAE,aAAAE,EAAc,YAAAC,CAAY,EAAIH,EACtClC,EAAa,KACT,GAAGoC,EAAa,iBAAiBtC,CAAS,EAC1C,GAAGuC,EAAY,gBAAgBvC,CAAS,CAC5C,EACA,KAAK,IAAI,MAAM,sBAAuB,CAClC,UAAAA,EACA,QAAS,IACb,CAAC,CACL,CACA,IAAMmC,EAAM,KAAKN,GACjB,GAAI,CACA,IAAM1B,EAAS,MAAMJ,EAAWC,EAAW,KAAME,CAAY,EAC7D,KAAK2B,GAAU1B,EACf,KAAK,cAAc,SAAUgC,CAAG,EAChC,KAAKH,GAAgB,KAAKF,EAAY,CAC1C,OAASU,EAAO,CACZ,KAAKhB,GAAS,OAAOgB,CAAK,CAC9B,CACJ,CACJ,CACJ,CJhQA,IAAMC,EAAW,cAEJC,EAAN,cAAoBC,EAAcC,EAAY,aAAa,CAAE,CAChEC,IAAkB,CACd,GAAM,CAAE,OAAAC,EAAQ,SAAAC,CAAS,EAAI,KACxBD,IACLE,EAAW,KAAK,OAASC,GAAUA,IAAUF,CAAQ,EACrD,KAAK,QAAQ,QAAQ,EACzB,CAEA,IAAI,UAAW,CACX,OAAO,MAAM,QACjB,CAEA,IAAI,SAASG,EAAO,CAChB,MAAM,SAAWA,CACrB,CAEA,kBAAmB,CACf,OAAO,IACX,CAMA,QAAQC,EAAS,CACb,MAAM,QAAQA,CAAO,EACrB,GAAM,CAAE,SAAAC,CAAS,EAAI,KACjBA,GAAYD,EAAQ,IAAI,UAAU,GAClC,KAAK,eAAe,IAAI,GAExBA,EAAQ,IAAI,QAAQ,GAAKA,EAAQ,IAAI,UAAU,IAC/C,KAAKN,GAAgB,CAE7B,CACJ,EAEA,OAAO,eAAe,OAAOJ,EAAUC,CAAK",
  "names": ["LitElement", "NAMESPACE", "CLASS_NAME_HIDDEN", "EVENT_TYPE_READY", "TAG_NAME_SERVICE", "dispatchAsyncEvent", "target", "type", "bubbles", "cancelable", "composed", "detail", "getCommonAncestor", "elements", "first", "rest", "ancestor", "element", "joinTokens", "tokens", "delimiter", "token", "makeCssClassName", "args", "NAMESPACE", "makeEventTypeName", "showOffers", "offers", "filter", "i", "offer", "CLASS_NAME_HIDDEN", "FAILED", "PENDING", "RESOLVED", "AsyncControl", "#error", "#options", "#state", "#target", "target", "cssPrefix", "eventOptions", "eventPrefix", "options", "state", "makeCssClassName", "makeEventTypeName", "#notify", "detail", "cssClassNames", "eventTypeNames", "dispatchAsyncEvent", "resolve", "reject", "error", "promise", "resolved", "failed", "once", "triggered", "onFailed", "event", "onResolved", "UNKNOWN_PLAN_TYPE", "makeOffers", "container", "filters", "placeholders", "offers", "placeholder", "i", "wcsOffers", "planType", "group", "candidate", "getCommonAncestor", "offer", "discoverService", "callback", "once", "head", "latest", "discover", "current", "TAG_NAME_SERVICE", "EVENT_TYPE_READY", "CommerceAware", "Component", "tagName", "#control", "AsyncControl", "#commerce", "#dispose", "#log", "#offers", "#preselected", "#selected", "#updateSelected", "value", "selected", "old", "commerce", "index", "CheckoutLink", "InlinePrice", "error", "TAG_NAME", "Stock", "CommerceAware", "LitElement", "#updateSelected", "offers", "selected", "showOffers", "offer", "value", "changed", "commerce"]
}
